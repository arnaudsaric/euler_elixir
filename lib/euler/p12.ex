defmodule Euler.P12 do

  @moduledoc """
  The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

  Let us list the factors of the first seven triangle numbers:

  1: 1
  3: 1,3
  6: 1,2,3,6
  10: 1,2,5,10
  15: 1,3,5,15
  21: 1,3,7,21
  28: 1,2,4,7,14,28
  We can see that 28 is the first triangle number to have over five divisors.

  What is the value of the first triangle number to have over five hundred divisors?
  """

  defp count_powers(p, num, acc\\1)
  defp count_powers(p, num, acc) when rem(num,p) == 0, do: count_powers(p, div(num,p), acc+1)
  defp count_powers(_p, _num, acc), do: acc

  defp count_divisors_p(num) do
    Euler.Lib.Primes.gen_primes_ets(num)
    sld = Euler.Lib.Primes.gen_primes_ets(num/2)
          |> Enum.map(&(count_powers(&1, num)))
          |> List.foldl(1,&(&1*&2))
    if Euler.Lib.Primes.is_prime?(num), do: 2*sld, else: sld
  end

  defp count_divisors(num, n\\0, sr\\nil, acc\\0)
  defp count_divisors(num, n, nil, acc), do: count_divisors(num, n, :math.sqrt(num), acc)
  defp count_divisors(_num, n, sr, acc) when n == sr, do: acc+1
  defp count_divisors(_num, n, sr, acc) when n > sr, do: acc
  defp count_divisors(num, n, sr, acc) when rem(num,n) == 0, do: count_divisors(num, n+1, sr, acc+2)
  defp count_divisors(num, n, sr, acc), do: count_divisors(num, n+1, sr, acc)

  @doc """

  ## Examples

      iex> Euler.P12.first_triangle 5
      28

  """
  def first_triangle(nb_divisors, current\\1, next_inc\\2)
  def first_triangle(nb_divisors, current, next_inc) do
    if count_divisors(current) >= nb_divisors do
      current
    else
      first_triangle(nb_divisors, current+next_inc, next_inc+1)
    end
  end

  @doc """
  Solves the challenge
  """
  def solve, do: IO.puts(first_triangle(500))

end

